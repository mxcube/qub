import qt
import thread
import threading
import sys


################################################################################
####################            QubThreadUpdater            ####################
################################################################################
class QubThreadUpdater(qt.QThread):
    """
    QubThreadUpdater is a base class to update data structure without blocking
    the Qt main event loop.
    Using start() method, you enter in an infinite loop which will poll for an
    update generated by the update() method. Once the update is received, a Qt
    CustomEvent is build in the buildEvent method which should be reimplemented
    and a CustomEvent is sent.
    You can stop the infinite loop using the stop() method.
    """
    def __init__(self, receiver=None, name=None):
        """
        Create the thread.
        Register the receiver of the CustomEvent
        Connect the aboutToQuit() signal of the application to the stop()
        method of the thread in order to leave safely the application.
        """
        qt.QThread.__init__(self)
        
        self.receiver = receiver
        self.name = name
        
        qt.QObject.connect(qt.qApp, qt.SIGNAL("aboutToQuit()"), self.stop)
        
        self.updateEvent = 0
        self.stopEvent   = 1

    def start(self, priority=qt.QThread.InheritPriority):
        """
        Start the thread
        """
        if self.stopEvent == 0:
            print self.name,": THREAD ALREADY STARTED"
        else:
            print self.name,": waiting to start ..."
            self.stopEvent = 0
            qt.QThread.start(self, priority)
        
    def stop(self):
        """
        stop the thread
        """
        self.stopEvent = 1
        print self.name,": waiting to finish ..."
        self.wait()
        print self.name,": finished"
        
    def update(self):
        """
        Send update to the infinite loop
        """
        self.updateEvent = 1

    def run(self):
        """
        Main Thread method.
        Enter in an infinite loop waiting for updateEvent.
        Once received, build event calling buildEvent method and
        send a Qt CustomEvent.
        """
        
        print self.name,": started"
        while self.stopEvent == 0:
            if self.updateEvent:

                self.updateEvent = 0
                
                event = self.buildEvent()      

                if event is not None:
                    qt.QApplication.postEvent(self.receiver, event)
            else :
                self.msleep(50)
                                
    def builldEvent(self):
        """
        To be reimplemented
        Build the event send to "receiver"
        """
        pass
 

################################################################################
####################            QubPixmap2Canvas            ####################
################################################################################
class QubPixmap2Canvas(QubThreadUpdater):
    """
    Create the displayable bckPixmap of a QubImage with dataPixmap and 
    the Transformation matrix of the QubImage Object ("receiver").
    When event is sent, bckPixmap is ready to be displayed
    """
    def __init__(self, receiver=None, name=None):
        """
        Constructor method
        Variables initialization
        """
        QubThreadUpdater.__init__(self, receiver, name)
        
        self.bckSize = (-1, -1)
        self.dataPixmap = None
        
    def buildEvent(self):
        """
        Build the event which will be sent to the QubImage object ("receiver")
        The event will not have any parameter as this class modify directly
        the QubImage attributes bckPixmap using the QubImage attributes
        dataPixmap and matrix
        """
        try:
            update = 0

            if self.receiver.dataPixmap is not None:
                neww = self.receiver.matrix.m11() * \
                       self.receiver.dataPixmap.width()
                newh = self.receiver.matrix.m22() * \
                       self.receiver.dataPixmap.height()

                if self.bckSize != (neww, newh):
                    if self.receiver.bckPixmap is not None:
                        self.receiver.bckPixmap.resize(neww, newh)
                    else:
                        self.receiver.bckPixmap = qt.QPixmap(neww, newh)
                    self.bckSize = (neww, newh)
                    update = 1

                if self.receiver.dataPixmap != self.dataPixmap:
                    self.dataPixmap = self.receiver.dataPixmap
                    update = 1           

            if update:
                qt.qApp.lock()
                painter  = qt.QPainter()
                painter.begin(self.receiver.bckPixmap)
                painter.setWorldMatrix(self.receiver.matrix)
                painter.drawPixmap(0, 0, self.receiver.dataPixmap)
                painter.end()
                qt.qApp.unlock()

                event = qt.QCustomEvent(qt.QEvent.User)
                event.event_name = "Pixmap2CanvasUpdated"

                return event
            else:
                return None
        except:
            sys.excepthook(sys.exc_info()[0],
                       sys.exc_info()[1],
                       sys.exc_info()[2])


################################################################################
####################             QubJpeg2Pixmap             ####################
################################################################################
class QubJpeg2Pixmap(QubThreadUpdater):
    """
    As Jpeg decompression may be slow, this QubThreadUpdater subclass
    transform JPEG data in QPixmap
    """
    def buildEvent(self):
        """
        Build event which will be sent to "receiver"
        Update directly the pixmap attribute of the receiver object
        """
        if self.receiver.data is not None:
            self.receiver.pixmap = qt.QPixmap()
            print self.name,": load jpeg"
            self.receiver.pixmap.loadFromData(self.receiver.data)
            print self.name,": load jpeg DONE"

            event = qt.QCustomEvent(QEvent.User)
            event.event_name = "Jpeg2PixmapUpdated"
           
            return event
        
        return None
